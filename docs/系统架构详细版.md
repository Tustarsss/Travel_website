# 个性化旅游推荐系统 - 系统设计文档

## 概述

个性化旅游推荐系统是一个基于图算法的智能旅游推荐与路径规划平台，提供景区推荐、路线规划、场所查询和旅游日记功能。该系统采用前后端分离架构，前端使用现代Web技术栈，后端基于Python FastAPI框架，数据库使用SQLite。

## 系统架构

### 整体架构

```
┌─────────────────┐    HTTP/REST API    ┌─────────────────┐
│   Frontend      │◄──────────────────►│   Backend       │
│   (Vue 3 + TS)  │                     │   (FastAPI)     │
└─────────────────┘                     └─────────────────┘
         │                                       │
         │                                       │
         ▼                                       ▼
┌─────────────────┐                     ┌─────────────────┐
│   Browser       │                     │   Database      │
│   (Leaflet Map) │                     │   (SQLite)      │
└─────────────────┘                     └─────────────────┘
```

### 前端架构

#### 技术栈
- **框架**: Vue 3 (Composition API) + TypeScript 5.8.3
- **构建工具**: Vite 7.1.7
- **UI框架**: Tailwind CSS 3.4.14
- **状态管理**: Pinia 3.0.3
- **路由**: Vue Router 4.5.1
- **地图**: Leaflet 1.9.4 (@vue-leaflet/vue-leaflet 0.10.1)
- **HTTP客户端**: Axios 1.12.2
- **富文本编辑器**: Tiptap (用于日记功能)
- **运行时**: Node.js >= 18.0.0

#### 组件架构

##### 页面组件 (pages/)
```
pages/
├── HomePage.vue          # 景区推荐主页
├── RoutingPage.vue       # 路线规划页面
├── FacilitiesPage.vue    # 场所查询页面
├── DiariesPage.vue       # 旅游日记列表页面
├── DiaryDetailPage.vue   # 日记详情页面
├── DiaryEditorPage.vue   # 日记编辑页面
├── LoginPage.vue         # 登录页面
├── RegisterPage.vue      # 注册页面
└── ProfilePage.vue       # 用户个人页面
```

##### UI基础组件 (components/ui/)
```
ui/
├── PageSection.vue       # 页面区块容器
├── ErrorAlert.vue        # 错误提示组件
├── LoadingIndicator.vue  # 加载指示器
├── EmptyState.vue        # 空状态占位组件
├── KeywordSearchSelect.vue # 关键词搜索选择器
└── Modal.vue            # 模态框组件
```

##### 地图组件 (components/map/)
```
map/
├── RouteMap.vue         # 路线地图展示组件
└── FacilitiesMap.vue    # 设施地图展示组件
```

##### 表单组件 (components/forms/)
```
forms/
├── RegionSearchForm.vue # 景区搜索表单
├── RoutePlanningForm.vue # 路线规划表单
├── FacilitiesSearchForm.vue # 设施搜索表单
└── DiaryEditorForm.vue  # 日记编辑表单
```

#### 状态管理 (stores/)

使用Pinia进行全局状态管理：

```typescript
// stores/preferences.ts - 用户偏好设置
export const usePreferencesStore = defineStore('preferences', {
  state: () => ({
    recommendations: {
      sortBy: 'hybrid' as RecommendationSort,
      interests: [] as string[],
      regionType: null as RegionType | null,
    },
    routing: {
      strategy: 'time' as WeightStrategy,
      transportModes: [] as TransportMode[],
    },
    facilities: {
      category: null as FacilityCategory | null,
      radius: 500,
    },
  }),
  persist: true  // 自动持久化到localStorage
})

// stores/auth.ts - 用户认证状态
export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null as User | null,
    token: null as string | null,
  }),
  actions: {
    async login(credentials: LoginCredentials) {
      // 登录逻辑
    },
    async logout() {
      // 登出逻辑
    }
  }
})
```

#### 组合式函数 (composables/)

##### useApiRequest - 通用API请求管理
```typescript
export function useApiRequest<T>(
  apiFunction: (...args: any[]) => Promise<AxiosResponse<T>>,
  options: {
    immediate?: boolean
    onSuccess?: (data: T) => void
    onError?: (error: any) => void
  } = {}
) {
  const data = ref<T | null>(null)
  const error = ref<any>(null)
  const loading = ref(false)

  const execute = async (...args: any[]) => {
    loading.value = true
    error.value = null
    try {
      const response = await apiFunction(...args)
      data.value = response.data
      options.onSuccess?.(data.value)
    } catch (err) {
      error.value = err
      options.onError?.(err)
    } finally {
      loading.value = false
    }
  }

  if (options.immediate) {
    execute()
  }

  return { data, error, loading, execute }
}
```

##### useDebounce - 防抖搜索
```typescript
export function useDebounce<T extends (...args: any[]) => any>(
  func: T,
  delay: number
): T {
  let timeoutId: NodeJS.Timeout
  return ((...args: any[]) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func(...args), delay)
  }) as T
}
```

#### API服务层 (services/)

##### apiClient配置
```typescript
// services/apiClient.ts
import axios from 'axios'

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api/v1',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
})

// 请求拦截器 - 添加认证token
apiClient.interceptors.request.use((config) => {
  const token = useAuthStore().token
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})

// 响应拦截器 - 处理错误
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      useAuthStore().logout()
      router.push('/login')
    }
    return Promise.reject(error)
  }
)

export default apiClient
```

##### API方法示例
```typescript
// services/api.ts
export const fetchRegionRecommendations = async (
  params: RecommendationQuery = {}
): Promise<RegionRecommendationResponse> => {
  const queryParams = {
    limit: params.limit,
    sort_by: params.sortBy,
    interests: params.interests?.length ? params.interests : undefined,
    interests_only: params.interestsOnly,
    q: params.search || undefined,
    region_type: params.regionType || undefined,
  }

  const { data } = await apiClient.get<RegionRecommendationResponse>(
    '/recommendations/regions',
    { params: queryParams }
  )
  return data
}
```

#### 路由配置

```typescript
// router/index.ts
const routes = [
  {
    path: '/',
    name: 'home',
    component: () => import('../pages/HomePage.vue'),
  },
  {
    path: '/routing',
    name: 'routing',
    component: () => import('../pages/RoutingPage.vue'),
  },
  {
    path: '/facilities',
    name: 'facilities',
    component: () => import('../pages/FacilitiesPage.vue'),
  },
  {
    path: '/diaries',
    name: 'diaries',
    component: () => import('../pages/DiariesPage.vue'),
  },
  {
    path: '/diaries/:id',
    name: 'diary-detail',
    component: () => import('../pages/DiaryDetailPage.vue'),
    props: true,
  },
  {
    path: '/login',
    name: 'login',
    component: () => import('../pages/LoginPage.vue'),
    meta: { requiresGuest: true },
  },
]

// 路由守卫
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore()

  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next('/login')
  } else if (to.meta.requiresGuest && authStore.isAuthenticated) {
    next('/')
  } else {
    next()
  }
})
```

### 后端架构

#### 技术栈
- **框架**: FastAPI
- **语言**: Python 3.11+
- **ORM**: SQLModel (基于SQLAlchemy 2.0.30)
- **数据库**: SQLite + aiosqlite 0.19.0
- **异步任务**: 基于Redis的缓存和任务队列
- **数据生成**: OSM数据集成 (osmnx, geopandas, shapely)
- **认证**: JWT + bcrypt + PyJWT
- **文档**: 自动生成Swagger/ReDoc
- **包管理**: uv (替代pip)
- **测试**: pytest + pytest-asyncio
- **代码质量**: ruff, mypy

#### 分层架构

```
Presentation Layer (API Endpoints)
    ↓ HTTP Requests/Responses
Controller Layer (FastAPI Routers)
    ↓ Dependency Injection
Service Layer (Business Logic)
    ↓ Data Access Abstraction
Repository Layer (Data Access)
    ↓ SQL Queries
Model Layer (SQLModel Entities)
    ↓ ORM Mapping
Database Layer (SQLite)
```

#### 核心模块详解

##### 1. API层 (`app/api/v1/endpoints/`)
FastAPI路由端点实现：

```python
# app/api/v1/endpoints/recommendations.py
@router.get("/regions", response_model=RegionRecommendationResponse)
async def get_region_recommendations(
    limit: int = Query(10, ge=1, le=100),
    sort_by: RecommendationSort = Query(RecommendationSort.HYBRID),
    interests: list[str] | None = Query(None),
    interests_only: bool = Query(False),
    q: str | None = Query(None),
    region_type: RegionType | None = Query(None),
    service: RecommendationService = Depends(get_recommendation_service),
) -> RegionRecommendationResponse:
    """获取景区推荐列表"""
    return await service.recommend_regions(
        limit=limit,
        sort_by=sort_by,
        interests=interests,
        search=q,
        region_type=region_type,
        interests_only=interests_only,
    )
```

##### 2. 服务层 (`app/services/`)
业务逻辑核心：

###### 路由服务 (RoutingService)
```python
class RoutingService:
    def __init__(self, graph_repository: GraphRepository, region_repository: RegionRepository):
        self._graph_repository = graph_repository
        self._region_repository = region_repository
        self._edges_cache: dict[int, list] = {}  # 区域边缓存
        self._nodes_cache: dict[int, GraphNode] = {}  # 节点缓存

    async def compute_route(self, *, region_id: int, start_node_id: int, end_node_id: int,
                          strategy: WeightStrategy = WeightStrategy.TIME,
                          transport_modes: Sequence[TransportMode] | None = None) -> RoutePlan:
        # 1. 验证区域和节点存在性
        region = await self._region_repository.get_region(region_id)
        if not region:
            raise RegionNotFoundError(f"Region {region_id} does not exist")

        # 2. 获取并缓存图数据
        edges = await self._get_edges_cached(region_id)
        algorithm_edges = self._to_algorithm_edges(edges)

        # 3. 执行最短路径算法
        result = shortest_path(
            algorithm_edges,
            start=str(start_node_id),
            goal=str(end_node_id),
            allowed_modes=allowed_modes,
            strategy=strategy,
        )

        # 4. 构建响应
        return RoutePlan(...)
```

###### 推荐服务 (RecommendationService)
```python
class RecommendationService:
    async def recommend_regions(self, *, limit: int = 10, sort_by: RecommendationSort = RecommendationSort.HYBRID,
                              interests: Sequence[str] | None = None, search: str | None = None,
                              region_type: RegionType | None = None, interests_only: bool = False) -> RecommendationResult:
        # 1. 获取候选区域
        regions = await self._region_repository.list_regions(region_type=region_type)

        # 2. 文本搜索过滤
        filtered = self._filter_by_search(regions, search)

        # 3. 计算推荐分数
        candidates = []
        for region in filtered:
            matches = self._match_interests(region, interest_terms)
            base_score = self._score_region(region, sort_by)
            interest_boost = self._interest_boost(len(matches), sort_by)
            final_score = base_score + interest_boost

            candidates.append(RegionRecommendation(...))

        # 4. Top-K排序
        ranked = PartialSorter.top_k(candidates, k=limit, key=lambda item: item.score)

        return RecommendationResult(...)
```

##### 3. 算法层 (`app/algorithms/`)
核心算法实现：

###### 最短路径算法 (shortest_path.py)
```python
def shortest_path(edges: Iterable[Edge], start: str, goal: str, *,
                 allowed_modes: Optional[Sequence[str]] = None,
                 strategy: WeightStrategy = WeightStrategy.TIME) -> PathResult:
    """
    Dijkstra算法实现，支持距离和时间两种权重策略
    """
    # 构建邻接表
    adjacency: Dict[str, List[Edge]] = {}
    for edge in edges:
        adjacency.setdefault(edge.source, []).append(edge)

    # 优先队列初始化
    queue: List[Tuple[float, int, str]] = []
    heappush(queue, (0.0, next(count()), start))

    # 距离和时间跟踪
    best_cost: Dict[str, float] = {start: 0.0}
    best_distance: Dict[str, float] = {start: 0.0}
    best_time: Dict[str, float] = {start: 0.0}

    while queue:
        cost, _, node = heappop(queue)
        if node in visited:
            continue

        # 扩展邻居节点
        for edge in adjacency.get(node, []):
            mode = _select_mode(edge, allowed)
            if not mode:
                continue

            # 计算新路径的代价
            new_distance = best_distance[node] + edge.distance
            new_time = best_time[node] + edge.travel_time
            new_cost = new_distance if strategy == WeightStrategy.DISTANCE else new_time

            if new_cost < best_cost.get(edge.target, inf):
                # 更新最优路径
                best_cost[edge.target] = new_cost
                best_distance[edge.target] = new_distance
                best_time[edge.target] = new_time
                heappush(queue, (new_cost, next(order), edge.target))

    # 重建路径
    return _reconstruct_path(start, goal, previous, best_distance, best_time)
```

###### 推荐算法 (diary_ranking.py)
```python
def ranking_algorithm(diaries: List[Diary], user_interests: List[str] = None,
                     top_k: int = 10) -> List[Tuple[Diary, float]]:
    """
    Top-K推荐算法：综合热度、评分和兴趣匹配
    """
    scored_diaries = []

    for diary in diaries:
        # 基础评分计算
        popularity_score = diary.view_count * 0.4
        rating_score = (diary.average_rating or 0) * 0.4

        # 兴趣匹配评分
        interest_score = 0.0
        if user_interests:
            interest_matches = sum(1 for interest in user_interests
                                 if interest.lower() in diary.tags_string.lower())
            interest_score = interest_matches * 0.2

        total_score = popularity_score + rating_score + interest_score
        scored_diaries.append((diary, total_score))

    # 使用堆排序获取Top-K
    return heapq.nlargest(top_k, scored_diaries, key=lambda x: x[1])
```

##### 4. 数据层 (`app/models/`, `app/repositories/`)
数据访问抽象：

###### 图数据模型
```python
class GraphNode(TimestampMixin, BaseModel, table=True):
    __tablename__ = "graph_nodes"

    region_id: int = Field(foreign_key="regions.id", index=True)
    name: Optional[str] = Field(default=None)
    latitude: float = Field(sa_column=Column(Float, nullable=False))
    longitude: float = Field(sa_column=Column(Float, nullable=False))
    building_id: Optional[int] = Field(default=None, foreign_key="buildings.id")
    facility_id: Optional[int] = Field(default=None, foreign_key="facilities.id")
    is_virtual: bool = Field(default=False)

    # 关系定义
    outgoing_edges: List["GraphEdge"] = Relationship(
        sa_relationship=relationship(
            "GraphEdge",
            primaryjoin="GraphNode.id == GraphEdge.start_node_id",
            foreign_keys="[GraphEdge.start_node_id]",
            cascade="all, delete-orphan",
            back_populates="start_node",
        )
    )
    incoming_edges: List["GraphEdge"] = Relationship(
        sa_relationship=relationship(
            "GraphEdge",
            primaryjoin="GraphNode.id == GraphEdge.end_node_id",
            foreign_keys="[GraphEdge.end_node_id]",
            cascade="all, delete-orphan",
            back_populates="end_node",
        )
    )

class GraphEdge(TimestampMixin, BaseModel, table=True):
    __tablename__ = "graph_edges"

    region_id: int = Field(foreign_key="regions.id", index=True)
    start_node_id: int = Field(foreign_key="graph_nodes.id", index=True)
    end_node_id: int = Field(foreign_key="graph_nodes.id", index=True)
    distance: float = Field(gt=0)  # 距离（米）
    ideal_speed: float = Field(gt=0)  # 理想速度（米/分钟）
    congestion: float = Field(gt=0, le=1)  # 拥挤度系数
    transport_modes: List[TransportMode] = Field(default_factory=list)

    # 双向关系
    start_node: GraphNode = Relationship(...)
    end_node: GraphNode = Relationship(...)
```

###### 仓库模式 (Repository Pattern)
```python
class GraphRepository:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def list_edges_by_region(self, region_id: int) -> List[GraphEdge]:
        """获取区域的所有边"""
        stmt = select(GraphEdge).where(GraphEdge.region_id == region_id)
        result = await self.session.execute(stmt)
        return list(result.scalars().all())

    async def get_node(self, node_id: int) -> GraphNode | None:
        """获取单个节点"""
        stmt = select(GraphNode).where(GraphNode.id == node_id)
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()

    async def get_nodes(self, node_ids: List[int]) -> List[GraphNode]:
        """批量获取节点"""
        stmt = select(GraphNode).where(GraphNode.id.in_(node_ids))
        result = await self.session.execute(stmt)
        return list(result.scalars().all())
```

### 数据库设计详解

#### 核心表结构详解

##### regions (景区信息)
```sql
CREATE TABLE regions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR NOT NULL UNIQUE,
    type VARCHAR NOT NULL CHECK (type IN ('scenic', 'campus')),
    popularity INTEGER DEFAULT 0 CHECK (popularity >= 0 AND popularity <= 100),
    rating REAL DEFAULT 0.0 CHECK (rating >= 0.0 AND rating <= 5.0),
    description TEXT,
    city VARCHAR,
    latitude REAL,
    longitude REAL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

##### graph_nodes (图节点)
```sql
CREATE TABLE graph_nodes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    region_id INTEGER NOT NULL REFERENCES regions(id) ON DELETE CASCADE,
    name VARCHAR,
    latitude REAL NOT NULL,
    longitude REAL NOT NULL,
    building_id INTEGER REFERENCES buildings(id),
    facility_id INTEGER REFERENCES facilities(id),
    is_virtual BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

##### graph_edges (图边)
```sql
CREATE TABLE graph_edges (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    region_id INTEGER NOT NULL REFERENCES regions(id) ON DELETE CASCADE,
    start_node_id INTEGER NOT NULL REFERENCES graph_nodes(id),
    end_node_id INTEGER NOT NULL REFERENCES graph_nodes(id),
    distance REAL NOT NULL CHECK (distance > 0),
    ideal_speed REAL NOT NULL CHECK (ideal_speed > 0),
    congestion REAL NOT NULL CHECK (congestion > 0 AND congestion <= 1),
    transport_modes JSON NOT NULL DEFAULT '[]',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

##### facilities (设施信息)
```sql
CREATE TABLE facilities (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    region_id INTEGER NOT NULL REFERENCES regions(id) ON DELETE CASCADE,
    name VARCHAR NOT NULL,
    category VARCHAR NOT NULL CHECK (category IN ('restaurant', 'shop', 'restroom', 'parking', 'medical', 'info_center', 'ticket_office', 'viewpoint')),
    latitude REAL NOT NULL,
    longitude REAL NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

##### diaries (旅游日记)
```sql
CREATE TABLE diaries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    region_id INTEGER REFERENCES regions(id),
    title VARCHAR NOT NULL,
    content TEXT,
    compressed_content BLOB,
    is_compressed BOOLEAN DEFAULT FALSE,
    media_urls JSON DEFAULT '[]',
    media_types JSON DEFAULT '[]',
    tags JSON DEFAULT '[]',
    status VARCHAR DEFAULT 'draft' CHECK (status IN ('draft', 'published')),
    view_count INTEGER DEFAULT 0,
    average_rating REAL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 索引优化
```sql
-- 区域查询索引
CREATE INDEX idx_regions_type ON regions(type);
CREATE INDEX idx_regions_city ON regions(city);

-- 图数据索引
CREATE INDEX idx_graph_nodes_region_id ON graph_nodes(region_id);
CREATE INDEX idx_graph_edges_region_id ON graph_edges(region_id);
CREATE INDEX idx_graph_edges_start_node ON graph_edges(start_node_id);
CREATE INDEX idx_graph_edges_end_node ON graph_edges(end_node_id);

-- 设施查询索引
CREATE INDEX idx_facilities_region_id ON facilities(region_id);
CREATE INDEX idx_facilities_category ON facilities(category);

-- 日记查询索引
CREATE INDEX idx_diaries_user_id ON diaries(user_id);
CREATE INDEX idx_diaries_region_id ON diaries(region_id);
CREATE INDEX idx_diaries_status ON diaries(status);
```

### 核心算法详解

#### 1. 路径规划算法
基于Dijkstra算法的改进实现：

**算法复杂度**: O((V + E) log V)，其中V为节点数，E为边数

**权重策略**:
- **距离优先**: `weight = edge.distance`
- **时间优先**: `weight = edge.distance / (edge.ideal_speed * edge.congestion)`

**交通方式过滤**:
```python
def _select_mode(edge: Edge, allowed: Optional[Tuple[str, ...]]) -> Optional[str]:
    if allowed is None:
        return edge.transport_modes[0]
    allowed_set = set(allowed)
    for mode in edge.transport_modes:
        if mode in allowed_set:
            return mode
    return None
```

#### 2. 设施查询算法
基于Dijkstra的单源最短路径扩展：

**核心思路**: 从起点开始，使用Dijkstra算法计算到所有可达节点的距离，然后过滤出有设施的节点

```python
async def compute_reachable_nodes(self, *, region_id: int, origin_node_id: int,
                                max_distance: float | None = None,
                                strategy: WeightStrategy = WeightStrategy.DISTANCE,
                                transport_modes: Sequence[TransportMode] | None = None) -> dict[int, dict[str, any]]:
    # 1. 构建加权邻接表
    graph: dict[int, list[tuple[int, float, float]]] = {}  # node_id -> [(neighbor_id, distance, time)]

    # 2. Dijkstra遍历所有可达节点
    distances: dict[int, float] = {origin_node_id: 0.0}
    heap = [(0.0, origin_node_id, 0.0, 0.0)]  # (priority, node_id, distance, time)

    while heap:
        priority, current_id, current_distance, current_time = heapq.heappop(heap)

        # 过滤设施节点
        if current_id in facility_nodes and current_distance <= max_distance:
            results[current_id] = {
                "distance": current_distance,
                "time": current_time,
                "path": reconstructed_path
            }
```

#### 3. 推荐算法
多维度Top-K排序：

**评分公式**:
```
final_score = base_score + interest_boost

base_score = {
    'popularity': region.popularity,
    'rating': region.rating,
    'hybrid': 0.6 * popularity + 0.4 * rating
}

interest_boost = match_count * weight
weight = 15.0 (非rating排序) | 4.0 (rating排序)
```

**Top-K排序实现**:
```python
def top_k(items: List[T], k: int, key: Callable[[T], float]) -> List[T]:
    """使用最小堆实现Top-K排序"""
    heap = []

    for item in items:
        score = key(item)
        if len(heap) < k:
            heapq.heappush(heap, (score, item))
        elif score > heap[0][0]:
            heapq.heapreplace(heap, (score, item))

    return [item for _, item in sorted(heap, reverse=True)]
```

### 数据流程详解

#### 地图数据生成流程
1. **OSM数据获取**
   ```python
   # 使用osmnx获取地理数据
   import osmnx as ox
   graph = ox.graph_from_place(place_name, network_type='walk')
   ```

2. **数据转换**
   ```python
   # 转换为内部数据格式
   nodes_data = []
   edges_data = []

   for node_id, node_data in graph.nodes(data=True):
       nodes_data.append({
           'id': node_id,
           'latitude': node_data['y'],
           'longitude': node_data['x'],
           'name': node_data.get('name', ''),
       })

   for start_id, end_id, edge_data in graph.edges(data=True):
       edges_data.append({
           'start_node_id': start_id,
           'end_node_id': end_id,
           'distance': edge_data['length'],
           'ideal_speed': 80.0,  # 米/分钟
           'congestion': 1.0,
           'transport_modes': ['walk'],
       })
   ```

3. **数据库持久化**
   ```python
   # 批量插入数据
   async with get_db_session() as session:
       await session.execute(insert(GraphNode), nodes_data)
       await session.execute(insert(GraphEdge), edges_data)
       await session.commit()
   ```

#### 用户请求处理流程
1. **前端请求**
   ```typescript
   const { data } = await apiClient.get('/routing/routes', {
     params: { region_id: 1, start_node_id: 10, end_node_id: 20, strategy: 'time' }
   })
   ```

2. **API路由分发**
   ```python
   @router.get("/routes", response_model=RoutePlanResponse)
   async def get_route_plan(
       region_id: int = Query(...),
       start_node_id: int = Query(...),
       end_node_id: int = Query(...),
       strategy: WeightStrategy = Query(WeightStrategy.TIME),
       transport_modes: List[TransportMode] | None = Query(None),
       service: RoutingService = Depends(get_routing_service),
   ) -> RoutePlanResponse:
       return await service.compute_route(
           region_id=region_id,
           start_node_id=start_node_id,
           end_node_id=end_node_id,
           strategy=strategy,
           transport_modes=transport_modes,
       )
   ```

3. **服务层处理**
   ```python
   async def compute_route(self, ...) -> RoutePlan:
       # 验证输入
       region = await self._region_repository.get_region(region_id)

       # 获取图数据（带缓存）
       edges = await self._get_edges_cached(region_id)

       # 执行算法
       result = shortest_path(edges, start=str(start_node_id), goal=str(end_node_id), ...)

       # 构建响应
       return RoutePlan(...)
   ```

4. **数据访问**
   ```python
   async def list_edges_by_region(self, region_id: int) -> List[GraphEdge]:
       stmt = select(GraphEdge).where(GraphEdge.region_id == region_id)
       result = await self.session.execute(stmt)
       return list(result.scalars().all())
   ```

### 性能优化策略

#### 后端优化

1. **图数据缓存**
   ```python
   class RoutingService:
       def __init__(self, ...):
           self._edges_cache: dict[int, list] = {}
           self._nodes_cache: dict[int, GraphNode] = {}

       async def _get_edges_cached(self, region_id: int) -> list:
           if region_id not in self._edges_cache:
               edges = await self._graph_repository.list_edges_by_region(region_id)
               self._edges_cache[region_id] = edges
           return self._edges_cache[region_id]
   ```

2. **批量数据库查询**
   ```python
   async def get_nodes(self, node_ids: List[int]) -> List[GraphNode]:
       """批量获取，减少数据库往返"""
       stmt = select(GraphNode).where(GraphNode.id.in_(node_ids))
       result = await self.session.execute(stmt)
       return list(result.scalars().all())
   ```

3. **异步处理**
   - 使用`asyncio`进行并发I/O操作
   - 数据库连接池复用
   - Redis缓存热点数据

#### 前端优化

1. **请求防抖**
   ```typescript
   const debouncedSearch = useDebounce((query: string) => {
     fetchRegionRecommendations({ search: query })
   }, 220)
   ```

2. **请求取消**
   ```typescript
   const abortController = new AbortController()

   const response = await apiClient.get('/api/endpoint', {
     signal: abortController.signal
   })

   // 新请求自动取消旧请求
   abortController.abort()
   ```

3. **状态持久化**
   ```typescript
   export const usePreferencesStore = defineStore('preferences', {
     persist: {
       storage: localStorage,
       paths: ['recommendations', 'routing', 'facilities']
     }
   })
   ```

### 部署架构

#### 开发环境
```
Frontend (Vite dev server)
├── Host: http://localhost:5173
├── Proxy: /api -> http://localhost:8000/api/v1
└── Hot reload: enabled

Backend (uvicorn)
├── Host: http://localhost:8000
├── Docs: http://localhost:8000/docs
├── ReDoc: http://localhost:8000/redoc
└── Auto reload: enabled

Database (SQLite)
└── File: data/travel.db
```

#### 生产环境
```
Load Balancer (nginx)
├── Frontend: static files
├── Backend: API proxy
└── SSL termination

Application Server (gunicorn + uvicorn workers)
├── Workers: 4
├── Host: unix socket
└── Timeout: 30s

Database (SQLite)
├── File: /var/data/travel.db
├── WAL mode: enabled
└── Backup: daily

Cache (Redis - optional)
├── Host: localhost:6379
├── TTL: 3600s
└── Max memory: 512MB
```

### 扩展性考虑

#### 水平扩展
- **API层**: 使用nginx负载均衡，部署多个FastAPI实例
- **缓存层**: Redis集群，支持数据分片
- **数据库**: 升级到PostgreSQL，支持读写分离

#### 功能扩展

1. **用户系统完善**
   ```python
   # 添加社交功能
   class UserFollowing(BaseModel, table=True):
       follower_id: int = Field(foreign_key="users.id")
       followed_id: int = Field(foreign_key="users.id")
       created_at: datetime

   # 好友推荐算法
   async def recommend_friends(self, user_id: int) -> List[User]:
       # 基于共同兴趣和地理位置的推荐
       pass
   ```

2. **实时功能**
   ```python
   # WebSocket支持
   from fastapi import WebSocket

   @app.websocket("/ws/routing/{route_id}")
   async def route_updates(websocket: WebSocket, route_id: int):
       await websocket.accept()
       # 实时路线更新推送
   ```

3. **AI增强**
   ```python
   # AIGC内容生成
   class AIGCService:
       async def generate_diary_content(self, photos: List[bytes]) -> str:
           # 调用AI模型生成日记内容
           pass

       async def generate_route_description(self, route: RoutePlan) -> str:
           # 生成路线描述
           pass
   ```

#### 数据扩展

1. **多数据源集成**
   ```python
   class DataSource(Enum):
       OSM = "osm"
       GOOGLE_MAPS = "google"
       CUSTOM = "custom"

   class ExternalDataImporter:
       async def import_from_osm(self, region_name: str) -> ImportedData:
           pass

       async def import_from_google(self, api_key: str, region: Region) -> ImportedData:
           pass
   ```

2. **实时数据**
   ```python
   class RealtimeDataService:
       async def get_traffic_congestion(self, edge_id: int) -> float:
           # 获取实时交通拥挤度
           pass

       async def get_weather_impact(self, region_id: int) -> Dict[str, float]:
           # 获取天气对出行影响
           pass
   ```

### 安全考虑

#### API安全
1. **JWT认证**
   ```python
   from jose import JWTError, jwt

   def create_access_token(data: dict) -> str:
       to_encode = data.copy()
       expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
       to_encode.update({"exp": expire})
       return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

   async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
       try:
           payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
           user_id: str = payload.get("sub")
           if user_id is None:
               raise HTTPException(status_code=401, detail="Invalid token")
       except JWTError:
           raise HTTPException(status_code=401, detail="Invalid token")
   ```

2. **CORS配置**
   ```python
   app.add_middleware(
       CORSMiddleware,
       allow_origins=settings.cors_allowed_origins,
       allow_credentials=True,
       allow_methods=["GET", "POST", "PUT", "DELETE"],
       allow_headers=["*"],
   )
   ```

3. **请求频率限制**
   ```python
   from slowapi import Limiter, _rate_limit_exceeded_handler
   from slowapi.util import get_remote_address
   from slowapi.middleware import SlowAPIMiddleware

   limiter = Limiter(key_func=get_remote_address)
   app.state.limiter = limiter
   app.add_exception_handler(429, _rate_limit_exceeded_handler)
   app.add_middleware(SlowAPIMiddleware)
   ```

#### 数据安全
1. **密码加密**
   ```python
   from passlib.context import CryptContext

   pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

   def verify_password(plain_password: str, hashed_password: str) -> bool:
       return pwd_context.verify(plain_password, hashed_password)

   def get_password_hash(password: str) -> str:
       return pwd_context.hash(password)
   ```

2. **SQL注入防护**
   - 使用SQLAlchemy ORM参数化查询
   - Pydantic模型输入验证

3. **敏感数据处理**
   ```python
   # 日记内容压缩存储
   compressed_content = zlib.compress(content.encode('utf-8'))
   # 媒体文件单独存储，不在数据库中保存二进制数据
   ```

### 监控和维护

#### 日志和监控
1. **结构化日志**
   ```python
   import structlog

   # 配置结构化日志
   shared_processors = [
       structlog.stdlib.filter_by_level,
       structlog.stdlib.add_logger_name,
       structlog.stdlib.add_log_level,
       structlog.stdlib.PositionalArgumentsFormatter(),
       structlog.processors.TimeStamper(fmt="iso"),
       structlog.processors.StackInfoRenderer(),
       structlog.processors.format_exc_info,
       structlog.processors.UnicodeDecoder(),
   ]

   structlog.configure(
       processors=shared_processors + [structlog.write_logs],
       context_class=dict,
       logger_factory=structlog.stdlib.LoggerFactory(),
       cache_logger_on_first_use=True,
   )
   ```

2. **性能监控**
   ```python
   from fastapi import Request, Response
   import time

   @app.middleware("http")
   async def add_process_time_header(request: Request, call_next):
       start_time = time.time()
       response = await call_next(request)
       process_time = time.time() - start_time
       response.headers["X-Process-Time"] = str(process_time)
       logger.info("Request processed", path=request.url.path, duration=process_time)
       return response
   ```

#### 数据维护
1. **自动化脚本**
   ```python
   # scripts/optimize_indexes.py
   async def optimize_database_indexes():
       """重建和优化数据库索引"""
       async with get_db_session() as session:
           await session.execute(text("REINDEX;"))
           await session.execute(text("VACUUM;"))
           await session.commit()

   # scripts/backup_database.py
   def backup_database(source_path: str, backup_path: str):
       """SQLite数据库备份"""
       import shutil
       shutil.copy2(source_path, backup_path)
   ```

2. **定时任务**
   ```python
   from app.services.task_service import scheduled_service

   # 每日凌晨2点执行维护任务
   @scheduled_service.schedule("0 2 * * *")
   async def daily_maintenance():
       await optimize_database_indexes()
       await backup_database()
       await clean_expired_cache()
   ```

---

**文档版本**: 2.0
**最后更新**: 2025年10月15日
**作者**: 系统架构团队